# -*- coding: utf-8 -*-
# Part of EBITS TechCon

from datetime import datetime
from odoo import api, fields, models, _
from odoo.addons import decimal_precision as dp
from odoo.exceptions import UserError, ValidationError
import logging

_logger = logging.getLogger(__name__)
# AFTER REMOVE ALREDY IN ODOO17 ###
class BranchOrderpoint(models.Model):
    """ Defines Minimum stock rules. """
    _name = "stock.branch.orderpoint"
    _description = "Branch Minimum Inventory Rule"

    @api.model
    def default_get(self, fields):
        res = super(BranchOrderpoint, self).default_get(fields)
        warehouse = None
        if 'warehouse_id' not in res and res.get('company_id'):
            warehouse = self.env['stock.warehouse'].search([('company_id', '=', res['company_id'])], limit=1)
        if warehouse:
            res['warehouse_id'] = warehouse.id
            res['location_id'] = warehouse.lot_stock_id.id
        return res

    name = fields.Char(
        'Name', copy=False, required=True,
        default=lambda self: self.env['ir.sequence'].next_by_code('stock.branch.orderpoint'))
    active = fields.Boolean(
        'Active', default=True,
        help="If the active field is set to False, it will allow you to hide the orderpoint without removing it.")
    warehouse_id = fields.Many2one(
        'stock.warehouse', 'Branch',
        ondelete="cascade", required=True)
    location_id = fields.Many2one(
        'stock.location', 'Location',
        ondelete="cascade", required=True)
    product_id = fields.Many2one(
        'product.product', 'Product',
        domain=[('type', '=', 'product')], ondelete='cascade', required=True)
    product_uom = fields.Many2one(
        'uom.uom', 'Product Unit of Measure', related='product_id.uom_id',
        readonly=True, required=True)
        # default=lambda self: self._context.get('product_uom', False))
    product_min_qty = fields.Float(
        'Minimum Quantity', digits=('Product Unit of Measure'), required=True,
        help="When the virtual stock goes below the Min Quantity specified for this field, Odoo generates "
             "a procurement to bring the forecasted quantity to the Max Quantity.")
    product_max_qty = fields.Float(
        'Maximum Quantity', digits=('Product Unit of Measure'), required=True,
        help="When the virtual stock goes below the Min Quantity, Odoo generates "
             "a procurement to bring the forecasted quantity to the Quantity specified as Max Quantity.")
    qty_multiple = fields.Float(
        'Qty Multiple', digits=('Product Unit of Measure'),
        default=1, required=True,
        help="The procurement quantity will be rounded up to this multiple.  If it is 0, the exact quantity will be used.")
    # MODEL NOT AVAILABLE ###
#    procurement_ids = fields.One2many('procurement.order', 'branch_point_id', 'Created Procurements')
#    group_id = fields.Many2one(
#        'procurement.group', 'Procurement Group', copy=False,
#        help="Moves created through this orderpoint will be put in this procurement group. If none is given, the moves generated by procurement rules will be grouped into one big picking.")
    company_id = fields.Many2one(
        'res.company', 'Company', required=True,
        default=lambda self: self.env['res.company']._company_default_get('stock.branch.orderpoint'))
    lead_days = fields.Integer(
        'Lead Time', default=1,
        help="Number of days after the orderpoint is triggered to receive the products or to order to the vendor")
    lead_type = fields.Selection(
        [('net', 'Day(s) to get the products'), ('supplier', 'Day(s) to purchase')], 'Lead Type',
        default='supplier')

    _sql_constraints = [
        ('qty_multiple_check', 'CHECK( qty_multiple >= 0 )', 'Qty Multiple must be greater than or equal to zero.'),
    ]

    @api.constrains('product_id')
    def _check_product_uom(self):
        ''' Check if the UoM has the same category as the product standard UoM '''
        if any(orderpoint.product_id.uom_id.category_id != orderpoint.product_uom.category_id for orderpoint in self):
            raise ValidationError(_('You have to select a product unit of measure in the same category than the default unit of measure of the product'))

    @api.onchange('warehouse_id')
    def onchange_warehouse_id(self):
        warning = {}
        if self.warehouse_id:
            self.location_id = self.warehouse_id.lot_stock_id.id
            if self.product_id and self.product_id.stock_warehouse_ids:
                if self.warehouse_id not in self.product_id.stock_warehouse_ids:
                    self.warehouse_id = False
                    warning = {
                        'title': _('Warning'),
                        'message': _('Selected warehouse not available in product stocking warehouse.')}
        else:
            self.location_id = False
        return {'warning': warning}

    @api.onchange('product_id')
    def onchange_product_id(self):
        warning = {}
        domain = {'product_uom':[]}
        if self.product_id:
            self.product_uom = self.product_id.uom_id.id
            domain = {'product_uom': [('category_id', '=', self.product_id.uom_id.category_id.id)]}
            if self.warehouse_id and self.product_id.stock_warehouse_ids:
                if self.warehouse_id not in self.product_id.stock_warehouse_ids:
                    self.warehouse_id = False
                    warning = {
                        'title': _('Warning'),
                        'message': _('Selected warehouse not available in product stocking warehouse.')}
        else:
            self.product_uom = False
        return {'warning': warning, 'domain': domain}
        
    
    def add_request_from_orderpoints(self):
        self._cr.execute("""SELECT 
                orderpoint.id as orderpoint_id, 
                itrl.id as itrl_id, 
                itrl.uom_id as uom_id, 
                itrl.required_qty as qty, 
                template.uom_id as template_uom_id
            FROM internal_stock_transfer_request_lines itrl 
                left join internal_stock_transfer_request as request on (request.id = itrl.request_id)
                left join stock_branch_orderpoint as orderpoint on (orderpoint.product_id = itrl.product_id)
                left join product_product as product on (product.id = itrl.product_id)
                left join product_template as template on (template.id = product.product_tmpl_id)
            WHERE itrl.state not in ('done', 'cancel')
                and request.state not in ('done', 'cancel')
                and request.requesting_warehouse_id = orderpoint.warehouse_id
                and orderpoint.id IN %s
            ORDER BY orderpoint.id, itrl.id
        """, (tuple(self.ids),))
        # UoM = self.env["product.uom"]
        UoM = self.env["uom.uom"]
        itrl_done = set()
        res = dict.fromkeys(self.ids, 0.0)
        for orderpoint_id, itrl_id, uom_id, qty, template_uom_id in self._cr.fetchall():
            if qty:
                if itrl_id not in itrl_done:
                    itrl_done.add(itrl_id)
                    res[orderpoint_id] += UoM.browse(uom_id)._compute_quantity((qty or 0.00), UoM.browse(template_uom_id), round=False)
        return res
        
    
    def add_issue_from_orderpoints(self):
        self._cr.execute("""SELECT 
                orderpoint.id as orderpoint_id, 
                issl.id as issl_id, 
                issl.uom_id as uom_id, 
                issl.approved_qty as approved_qty, 
                issl.issued_qty as issued_qty, 
                template.uom_id as template_uom_id
            FROM internal_stock_transfer_issue_line issl 
                left join internal_stock_transfer_issue as issue on (issue.id = issl.issue_id)
                left join internal_stock_transfer_master as master on (master.id = issue.warehouse_master_id)
                left join stock_branch_orderpoint as orderpoint on (orderpoint.product_id = issl.product_id)
                left join product_product as product on (product.id = issl.product_id)
                left join product_template as template on (template.id = product.product_tmpl_id)
            WHERE issl.state != 'done'
                and issue.state != 'done'
                and master.requesting_warehouse_id = orderpoint.warehouse_id
                and orderpoint.id IN %s
            ORDER BY orderpoint.id, issl.id
        """, (tuple(self.ids),))
        # UoM = self.env["product.uom"]
        UoM = self.env["uom.uom"]
        issl_done = set()
        res = dict.fromkeys(self.ids, 0.0)
        for orderpoint_id, issl_id, uom_id, approved_qty, issued_qty, template_uom_id in self._cr.fetchall():
            if issl_id not in issl_done:
                issl_done.add(issl_id)
                res[orderpoint_id] += UoM.browse(uom_id)._compute_quantity(((approved_qty or 0.00) - (issued_qty or 0.00)), UoM.browse(template_uom_id), round=False)
        return res
        
    
    def add_receive_from_orderpoints(self):
        self._cr.execute("""SELECT 
                orderpoint.id as orderpoint_id, 
                receiptl.id as receiptl_id, 
                receiptl.uom_id as uom_id, 
                receiptl.issued_qty as issued_qty, 
                receiptl.received_qty as received_qty, 
                template.uom_id as template_uom_id
            FROM internal_stock_transfer_receipt_line receiptl 
                left join internal_stock_transfer_receipt as receipt on (receipt.id = receiptl.receipt_id)
                left join stock_branch_orderpoint as orderpoint on (orderpoint.product_id = receiptl.product_id)
                left join product_product as product on (product.id = receiptl.product_id)
                left join product_template as template on (template.id = product.product_tmpl_id)
            WHERE receiptl.state != 'done'
                and receipt.state != 'done'
                and receipt.receiving_warehouse_id = orderpoint.warehouse_id
                and orderpoint.id IN %s
            ORDER BY orderpoint.id, receiptl.id
        """, (tuple(self.ids),))
        # UoM = self.env["product.uom"]
        UoM = self.env["uom.uom"]
        issl_done = set()
        res = dict.fromkeys(self.ids, 0.0)
        for orderpoint_id, receiptl_id, uom_id, issued_qty, received_qty, template_uom_id in self._cr.fetchall():
            if receiptl_id not in issl_done:
                issl_done.add(receiptl_id)
                res[orderpoint_id] += UoM.browse(uom_id)._compute_quantity(((issued_qty or 0.00) - (received_qty or 0.00)), UoM.browse(template_uom_id), round=False)
        return res
        
    
    def subtract_request_from_orderpoints(self):
        self._cr.execute("""SELECT 
                orderpoint.id as orderpoint_id, 
                itrl.id as itrl_id, 
                itrl.uom_id as uom_id, 
                itrl.qty as qty, 
                template.uom_id as template_uom_id
            FROM internal_stock_transfer_request_lines itrl 
                left join internal_stock_transfer_request as request on (request.id = itrl.request_id)
                left join stock_branch_orderpoint as orderpoint on (orderpoint.product_id = itrl.product_id)
                left join internal_stock_transfer_master master on (master.id = request.warehouse_master_id)
                left join product_product as product on (product.id = itrl.product_id)
                left join product_template as template on (template.id = product.product_tmpl_id)
            WHERE itrl.state not in ('done', 'cancel')
                and request.state not in ('done', 'cancel')
                and master.issuing_warehouse_id = orderpoint.warehouse_id
                and orderpoint.id IN %s
            ORDER BY orderpoint.id, itrl.id
        """, (tuple(self.ids),))
        # UoM = self.env["product.uom"]
        UoM = self.env["uom.uom"]
        itrl_done = set()
        res = dict.fromkeys(self.ids, 0.0)
        for orderpoint_id, itrl_id, uom_id, qty, template_uom_id in self._cr.fetchall():
            if itrl_id not in itrl_done:
                itrl_done.add(itrl_id)
                res[orderpoint_id] += UoM.browse(uom_id)._compute_quantity(qty, UoM.browse(template_uom_id), round=False)
        return res
        
    
    def subtract_issue_from_orderpoints(self):
        self._cr.execute("""SELECT 
                orderpoint.id as orderpoint_id, 
                issl.id as issl_id, 
                issl.uom_id as uom_id, 
                issl.approved_qty as approved_qty, 
                issl.issued_qty as issued_qty, 
                template.uom_id as template_uom_id
            FROM internal_stock_transfer_issue_line issl 
                left join internal_stock_transfer_issue as issue on (issue.id = issl.issue_id)
                left join stock_branch_orderpoint as orderpoint on (orderpoint.product_id = issl.product_id)
                left join product_product as product on (product.id = issl.product_id)
                left join product_template as template on (template.id = product.product_tmpl_id)
            WHERE issl.state != 'done'
                and issue.state != 'done'
                and issue.issuing_warehouse_id = orderpoint.warehouse_id
                and orderpoint.id IN %s
            ORDER BY orderpoint.id, issl.id
        """, (tuple(self.ids),))
        # UoM = self.env["product.uom"]
        UoM = self.env["uom.uom"]
        issl_done = set()
        res = dict.fromkeys(self.ids, 0.0)
        for orderpoint_id, issl_id, uom_id, approved_qty, issued_qty, template_uom_id in self._cr.fetchall():
            if issl_id not in issl_done:
                issl_done.add(issl_id)
                res[orderpoint_id] += UoM.browse(uom_id)._compute_quantity(((approved_qty or 0.00) - (issued_qty or 0.00)), UoM.browse(template_uom_id), round=False)
        return res
        
# BranchOrderpoint()
